From: David Steele <steele@debian.org>
Date: Fri, 2 Jun 2017 11:23:37 -0400
Subject: Remove fusermount tests, for autopkgtest

The ability to mount fuse filesystems is not available.
---
 tests/cli/cli_test.go                              | 152 -----
 tests/defaults/main_test.go                        | 118 ----
 .../example_filesystems_test.go                    | 144 ----
 tests/matrix/matrix_test.go                        | 754 ---------------------
 tests/plaintextnames/plaintextnames_test.go        |  84 ---
 tests/reverse/correctness_test.go                  |  91 ---
 tests/reverse/ctlsock_test.go                      |  68 --
 tests/reverse/longname_perf_test.go                |  50 --
 tests/reverse/main_test.go                         |  56 --
 9 files changed, 1517 deletions(-)
 delete mode 100644 tests/defaults/main_test.go
 delete mode 100644 tests/matrix/matrix_test.go
 delete mode 100644 tests/plaintextnames/plaintextnames_test.go
 delete mode 100644 tests/reverse/correctness_test.go
 delete mode 100644 tests/reverse/ctlsock_test.go
 delete mode 100644 tests/reverse/longname_perf_test.go
 delete mode 100644 tests/reverse/main_test.go

diff --git a/tests/cli/cli_test.go b/tests/cli/cli_test.go
index cce7fa0..bcb6f31 100644
--- a/tests/cli/cli_test.go
+++ b/tests/cli/cli_test.go
@@ -6,7 +6,6 @@ import (
 	"io/ioutil"
 	"os"
 	"os/exec"
-	"syscall"
 	"testing"
 
 	"github.com/rfjakob/gocryptfs/internal/configfile"
@@ -94,94 +93,6 @@ func testPasswd(t *testing.T, dir string, extraArgs ...string) {
 	}
 }
 
-// Test -passwd flag
-func TestPasswd(t *testing.T) {
-	// Create FS
-	dir := test_helpers.InitFS(t)
-	mnt := dir + ".mnt"
-	// Add content
-	test_helpers.MountOrFatal(t, dir, mnt, "-extpass", "echo test")
-	file1 := mnt + "/file1"
-	err := ioutil.WriteFile(file1, []byte("somecontent"), 0600)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = test_helpers.UnmountErr(mnt)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// Change password to "newpasswd"
-	testPasswd(t, dir)
-	// Mount and verify
-	test_helpers.MountOrFatal(t, dir, mnt, "-extpass", "echo newpasswd")
-	content, err := ioutil.ReadFile(file1)
-	if err != nil {
-		t.Error(err)
-	} else if string(content) != "somecontent" {
-		t.Errorf("wrong content: %q", string(content))
-	}
-	err = test_helpers.UnmountErr(mnt)
-	if err != nil {
-		t.Fatal(err)
-	}
-}
-
-// Test -passwd with -masterkey
-func TestPasswdMasterkey(t *testing.T) {
-	// Create FS
-	dir := test_helpers.InitFS(t)
-	// Overwrite with config with known master key
-	conf, err := ioutil.ReadFile("gocryptfs.conf.b9e5ba23")
-	if err != nil {
-		t.Fatal(err)
-	}
-	syscall.Unlink(dir + "/gocryptfs.conf")
-	err = ioutil.WriteFile(dir+"/gocryptfs.conf", conf, 0600)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// Add content
-	mnt := dir + ".mnt"
-	test_helpers.MountOrFatal(t, dir, mnt, "-extpass", "echo test")
-	file1 := mnt + "/file1"
-	err = ioutil.WriteFile(file1, []byte("somecontent"), 0600)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.UnmountPanic(mnt)
-	// Change password using stdin
-	args := []string{"-q", "-passwd", "-masterkey",
-		"b9e5ba23-981a22b8-c8d790d8-627add29-f680513f-b7b7035f-d203fb83-21d82205"}
-	args = append(args, dir)
-	cmd := exec.Command(test_helpers.GocryptfsBinary, args...)
-	cmd.Stdout = os.Stdout
-	cmd.Stderr = os.Stderr
-	p, err := cmd.StdinPipe()
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = cmd.Start()
-	if err != nil {
-		t.Error(err)
-	}
-	// New password
-	p.Write([]byte("newpasswd\n"))
-	p.Close()
-	err = cmd.Wait()
-	if err != nil {
-		t.Error(err)
-	}
-	// Mount and verify
-	test_helpers.MountOrFatal(t, dir, mnt, "-extpass", "echo newpasswd")
-	content, err := ioutil.ReadFile(file1)
-	if err != nil {
-		t.Error(err)
-	} else if string(content) != "somecontent" {
-		t.Errorf("wrong content: %q", string(content))
-	}
-	test_helpers.UnmountPanic(mnt)
-}
-
 // Test -passwd with -reverse
 func TestPasswdReverse(t *testing.T) {
 	// Create FS
@@ -210,69 +121,6 @@ func TestInitConfig(t *testing.T) {
 	}
 }
 
-// Test -ro
-func TestRo(t *testing.T) {
-	dir := test_helpers.InitFS(t)
-	mnt := dir + ".mnt"
-	test_helpers.MountOrFatal(t, dir, mnt, "-ro", "-extpass=echo test")
-	defer test_helpers.UnmountPanic(mnt)
-
-	file := mnt + "/file"
-	err := os.Mkdir(file, 0777)
-	if err == nil {
-		t.Errorf("Mkdir should have failed")
-	}
-	_, err = os.Create(file)
-	if err == nil {
-		t.Errorf("Create should have failed")
-	}
-}
-
-// Test "-nonempty"
-func TestNonempty(t *testing.T) {
-	dir := test_helpers.InitFS(t)
-	mnt := dir + ".mnt"
-	err := os.Mkdir(mnt, 0700)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = ioutil.WriteFile(mnt+"/somefile", []byte("xyz"), 0600)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = test_helpers.Mount(dir, mnt, false, "-extpass=echo test")
-	if err == nil {
-		t.Errorf("Mounting over a file should fail per default")
-	}
-	// Should work with "-nonempty"
-	test_helpers.MountOrFatal(t, dir, mnt, "-nonempty", "-extpass=echo test")
-	test_helpers.UnmountPanic(mnt)
-}
-
-// Test "mountpoint shadows cipherdir" handling
-func TestShadows(t *testing.T) {
-	mnt := test_helpers.InitFS(t)
-	cipher := mnt + ".cipher"
-	err := os.Rename(mnt, cipher)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// This should work
-	// (note that MountOrFatal creates "mnt" again)
-	test_helpers.MountOrFatal(t, cipher, mnt, "-extpass=echo test")
-	test_helpers.UnmountPanic(mnt)
-	cipher2 := mnt + "/cipher"
-	err = os.Rename(cipher, cipher2)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// This should fail
-	err = test_helpers.Mount(cipher2, mnt, false, "-extpass=echo test")
-	if err == nil {
-		t.Errorf("Should have failed")
-	}
-}
-
 // TestInitTrailingGarbage verfies that gocryptfs exits with an error if we
 // pass additional data after the password.
 func TestInitTrailingGarbage(t *testing.T) {
diff --git a/tests/defaults/main_test.go b/tests/defaults/main_test.go
deleted file mode 100644
index 52ca727..0000000
--- a/tests/defaults/main_test.go
+++ /dev/null
@@ -1,118 +0,0 @@
-// Tests and benchmarks performed with default settings only.
-package defaults
-
-import (
-	"bytes"
-	"os"
-	"os/exec"
-	"syscall"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/internal/ctlsock"
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-func TestMain(m *testing.M) {
-	test_helpers.ResetTmpDir(true)
-	test_helpers.MountOrExit(test_helpers.DefaultCipherDir, test_helpers.DefaultPlainDir, "-zerokey")
-	r := m.Run()
-	test_helpers.UnmountPanic(test_helpers.DefaultPlainDir)
-	os.Exit(r)
-}
-
-// Test that we get the right timestamp when extracting a tarball.
-func Test1980Tar(t *testing.T) {
-	c := exec.Command("tar", "xzf", "1980.tar.gz", "-C", test_helpers.DefaultPlainDir)
-	c.Stderr = os.Stderr
-	c.Stdout = os.Stdout
-	err := c.Run()
-	if err != nil {
-		t.Fatal(err)
-	}
-	fi, err := os.Stat(test_helpers.DefaultPlainDir + "/1980.txt")
-	if err != nil {
-		t.Fatal(err)
-	}
-	m := fi.ModTime().Unix()
-	if m != 315619323 {
-		t.Errorf("Wrong mtime: %d", m)
-	}
-}
-
-func TestCtlSock(t *testing.T) {
-	cDir := test_helpers.InitFS(t)
-	pDir := cDir + ".mnt"
-	sock := cDir + ".sock"
-	test_helpers.MountOrFatal(t, cDir, pDir, "-ctlsock="+sock, "-extpass", "echo test")
-	defer test_helpers.UnmountPanic(pDir)
-	req := ctlsock.RequestStruct{
-		EncryptPath: "foobar",
-	}
-	response := test_helpers.QueryCtlSock(t, sock, req)
-	if response.Result == "" || response.ErrNo != 0 {
-		t.Errorf("got an error reply: %+v", response)
-	}
-	req.EncryptPath = "not-existing-dir/xyz"
-	response = test_helpers.QueryCtlSock(t, sock, req)
-	if response.ErrNo != int32(syscall.ENOENT) || response.Result != "" {
-		t.Errorf("incorrect error handling: %+v", response)
-	}
-	// Strange paths should not cause a crash
-	crashers := []string{"/foo", "foo/", "/foo/", ".", "/////", "/../../."}
-	for _, c := range crashers {
-		req.EncryptPath = c
-		// QueryCtlSock calls t.Fatal if it gets EOF when gocryptfs panics
-		response = test_helpers.QueryCtlSock(t, sock, req)
-		if response.WarnText == "" {
-			t.Errorf("We should get a warning about non-canonical paths here")
-		}
-	}
-}
-
-// In gocryptfs before v1.2, the file header was only read once for each
-// open. But truncating a file to zero will generate a new random file ID.
-// The sequence below caused an I/O error to be returned.
-func TestOpenTruncateRead(t *testing.T) {
-	fn := test_helpers.DefaultPlainDir + "/TestTruncateWrite"
-	// First FD is used for write and trucate.
-	writeFd, err := os.Create(fn)
-	if err != nil {
-		t.Fatal(err)
-	}
-	abc := []byte("abc")
-	_, err = writeFd.WriteAt(abc, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// Second FD is just for reading.
-	readFd, err := os.Open(fn)
-	if err != nil {
-		t.Fatal(err)
-	}
-	content := make([]byte, 3)
-	_, err = readFd.ReadAt(content, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if !bytes.Equal(content, abc) {
-		t.Fatalf("wrong content: %s", string(content))
-	}
-	// Truncate to zero to generate a new file ID and write new content.
-	err = writeFd.Truncate(0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	xyz := []byte("xyz")
-	_, err = writeFd.WriteAt(xyz, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// Try to read from the other FD.
-	_, err = readFd.ReadAt(content, 0)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if !bytes.Equal(content, xyz) {
-		t.Fatalf("wrong content: %s", string(content))
-	}
-}
diff --git a/tests/example_filesystems/example_filesystems_test.go b/tests/example_filesystems/example_filesystems_test.go
index 5192278..c2d33e0 100644
--- a/tests/example_filesystems/example_filesystems_test.go
+++ b/tests/example_filesystems/example_filesystems_test.go
@@ -88,147 +88,3 @@ func TestExampleFSv06PlaintextNames(t *testing.T) {
 	}
 }
 
-// Test example_filesystems/v0.7
-// with password mount and -masterkey mount
-// v0.7 adds 128 bit GCM IVs
-func TestExampleFSv07(t *testing.T) {
-	cDir := "v0.7"
-	pDir := test_helpers.TmpDir + "/" + cDir
-	err := os.Mkdir(pDir, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.MountOrFatal(t, cDir, pDir, "-extpass", "echo test", opensslOpt)
-	checkExampleFS(t, pDir, true)
-	test_helpers.UnmountPanic(pDir)
-	test_helpers.MountOrFatal(t, cDir, pDir, "-masterkey",
-		"ed7f6d83-40cce86c-0e7d79c2-a9438710-575221bf-30a0eb60-2821fa8f-7f3123bf",
-		opensslOpt)
-	checkExampleFS(t, pDir, true)
-	test_helpers.UnmountPanic(pDir)
-}
-
-// gocryptfs v0.7 filesystem created with "-plaintextnames"
-func TestExampleFSv07PlaintextNames(t *testing.T) {
-	cDir := "v0.7-plaintextnames"
-	pDir := test_helpers.TmpDir + "/" + cDir + ".mnt"
-
-	test_helpers.MountOrFatal(t, cDir, pDir, "-extpass", "echo test", opensslOpt)
-	checkExampleFS(t, pDir, true)
-	test_helpers.UnmountPanic(pDir)
-	// The actual unmount takes some time, this causes weird problems. Just don't
-	// reuse the mountpoint.
-	pDir = pDir + ".2"
-	test_helpers.MountOrFatal(t, cDir, pDir, "-plaintextnames", "-masterkey",
-		"6d96397b-585631e1-c7cba69d-61e738b6-4d5ad2c2-e21f0fb3-52f60d3a-b08526f7",
-		opensslOpt)
-	checkExampleFS(t, pDir, true)
-	test_helpers.UnmountPanic(pDir)
-}
-
-// Test example_filesystems/v0.9
-// (gocryptfs v0.9 introduced long file name support)
-func TestExampleFSv09(t *testing.T) {
-	cDir := "v0.9"
-	pDir := test_helpers.TmpDir + "/" + cDir
-	err := os.Mkdir(pDir, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.MountOrFatal(t, cDir, pDir, "-extpass", "echo test", opensslOpt)
-	checkExampleFSLongnames(t, pDir)
-	test_helpers.UnmountPanic(pDir)
-	pDir = pDir + ".2"
-	test_helpers.MountOrFatal(t, cDir, pDir, "-masterkey",
-		"1cafe3f4-bc316466-2214c47c-ecd89bf3-4e078fe4-f5faeea7-8b7cab02-884f5e1c",
-		opensslOpt)
-	checkExampleFSLongnames(t, pDir)
-	test_helpers.UnmountPanic(pDir)
-}
-
-// gocryptfs v1.1 introduced AES-SIV
-func TestExampleFSv11(t *testing.T) {
-	cDir := "v1.1-aessiv"
-	pDir := test_helpers.TmpDir + "/" + cDir
-	err := os.Mkdir(pDir, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.MountOrFatal(t, cDir, pDir, "-extpass", "echo test", opensslOpt)
-	checkExampleFSLongnames(t, pDir)
-	test_helpers.UnmountPanic(pDir)
-	pDir = pDir + ".2"
-	test_helpers.MountOrFatal(t, cDir, pDir, "-masterkey",
-		"eaf371c3-f9a55336-8819f22b-7bccd7c2-a738cf61-7261c658-14c28a03-9428992b",
-		"-aessiv", opensslOpt)
-	checkExampleFSLongnames(t, pDir)
-	test_helpers.UnmountPanic(pDir)
-}
-
-// gocryptfs v1.1 introduced reverse mode
-func TestExampleFSv11reverse(t *testing.T) {
-	dirA := "v1.1-reverse"
-	dirB := test_helpers.TmpDir + "/" + dirA + ".B"
-	err := os.Mkdir(dirB, 0700)
-	if err != nil {
-		t.Fatal(err)
-	}
-	dirC := test_helpers.TmpDir + "/" + dirA + ".C"
-	err = os.Mkdir(dirC, 0700)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.MountOrFatal(t, dirA, dirB, "-reverse", "-extpass", "echo test", opensslOpt)
-	c := dirB + "/gocryptfs.conf"
-	if !test_helpers.VerifyExistence(c) {
-		t.Errorf("%s missing", c)
-	}
-	test_helpers.MountOrFatal(t, dirB, dirC, "-extpass", "echo test", opensslOpt)
-	checkExampleFSrw(t, dirC, false)
-	test_helpers.UnmountPanic(dirC)
-	test_helpers.UnmountPanic(dirB)
-
-	m := "68b51855-042abd80-635ae1ba-90152a78-2ec2d243-832ac72a-eab0561a-f2d37913"
-	test_helpers.MountOrFatal(t, dirA, dirB, "-reverse", "-masterkey", m, opensslOpt)
-	if !test_helpers.VerifyExistence(c) {
-		t.Errorf("%s missing", c)
-	}
-	test_helpers.MountOrFatal(t, dirB, dirC, "-aessiv", "-masterkey", m, opensslOpt)
-	checkExampleFSrw(t, dirC, false)
-	test_helpers.UnmountPanic(dirC)
-	test_helpers.UnmountPanic(dirB)
-}
-
-// gocryptfs v1.1 introduced reverse mode
-func TestExampleFSv11reversePlaintextnames(t *testing.T) {
-	dirA := "v1.1-reverse-plaintextnames"
-	dirB := test_helpers.TmpDir + "/" + dirA + ".B"
-	err := os.Mkdir(dirB, 0700)
-	if err != nil {
-		t.Fatal(err)
-	}
-	dirC := test_helpers.TmpDir + "/" + dirA + ".C"
-	err = os.Mkdir(dirC, 0700)
-	if err != nil {
-		t.Fatal(err)
-	}
-	test_helpers.MountOrFatal(t, dirA, dirB, "-reverse", "-extpass", "echo test", opensslOpt)
-	c := dirB + "/gocryptfs.conf"
-	if !test_helpers.VerifyExistence(c) {
-		t.Errorf("%s missing", c)
-	}
-	test_helpers.MountOrFatal(t, dirB, dirC, "-extpass", "echo test", opensslOpt)
-	checkExampleFSrw(t, dirC, false)
-	test_helpers.UnmountPanic(dirC)
-	test_helpers.UnmountPanic(dirB)
-
-	m := "e7fb8f0d-2a81df9e-26611e4b-5540b218-e48aa458-c2a623af-d0c82637-1466b5f2"
-	test_helpers.MountOrFatal(t, dirA, dirB, "-reverse", "-masterkey", m, opensslOpt)
-	if !test_helpers.VerifyExistence(c) {
-		t.Errorf("%s missing", c)
-	}
-	test_helpers.MountOrFatal(t, dirB, dirC, "-aessiv", "-masterkey", m, opensslOpt)
-	checkExampleFSrw(t, dirC, false)
-	test_helpers.UnmountPanic(dirC)
-	test_helpers.UnmountPanic(dirB)
-}
diff --git a/tests/matrix/matrix_test.go b/tests/matrix/matrix_test.go
deleted file mode 100644
index 1c5d348..0000000
--- a/tests/matrix/matrix_test.go
+++ /dev/null
@@ -1,754 +0,0 @@
-// Tests run for (almost all) combinations of openssl, aessiv, plaintextnames.
-package matrix
-
-// File reading, writing, modification, truncate
-//
-// Runs everything four times, for all combinations of
-// "-plaintextnames" and "-openssl".
-//
-// Test Matrix:
-//                       openssl=true openssl=false
-// plaintextnames=false  X            X
-// plaintextnames=true   X            X
-
-import (
-	"bytes"
-	"flag"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"os/exec"
-	"runtime"
-	"sync"
-	"syscall"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/internal/cryptocore"
-	"github.com/rfjakob/gocryptfs/internal/nametransform"
-	"github.com/rfjakob/gocryptfs/internal/syscallcompat"
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-// Several tests need to be aware if plaintextnames is active or not, so make this
-// a global variable
-var testcase testcaseMatrix
-
-type testcaseMatrix struct {
-	plaintextnames bool
-	openssl        string
-	aessiv         bool
-	raw64          bool
-}
-
-var matrix = []testcaseMatrix{
-	// Normal
-	{false, "auto", false, false},
-	{false, "true", false, false},
-	{false, "false", false, false},
-	// Plaintextnames
-	{true, "true", false, false},
-	{true, "false", false, false},
-	// AES-SIV (does not use openssl, no need to test permutations)
-	{false, "auto", true, false},
-	{true, "auto", true, false},
-	// Raw64
-	{false, "auto", false, true},
-}
-
-// This is the entry point for the tests
-func TestMain(m *testing.M) {
-	// Make "testing.Verbose()" return the correct value
-	flag.Parse()
-	for _, testcase = range matrix {
-		if !cryptocore.HaveModernGoGCM && testcase.openssl != "true" {
-			fmt.Printf("Skipping Go GCM variant, Go installation is too old")
-			continue
-		}
-		if testcase.raw64 && !nametransform.HaveRaw64 {
-			fmt.Printf("Skipping raw64 test, Go installation is too old")
-			continue
-		}
-		if testing.Verbose() {
-			fmt.Printf("matrix: testcase = %#v\n", testcase)
-		}
-		test_helpers.ResetTmpDir(!testcase.plaintextnames)
-		opts := []string{"-zerokey"}
-		opts = append(opts, fmt.Sprintf("-openssl=%v", testcase.openssl))
-		opts = append(opts, fmt.Sprintf("-plaintextnames=%v", testcase.plaintextnames))
-		opts = append(opts, fmt.Sprintf("-aessiv=%v", testcase.aessiv))
-		opts = append(opts, fmt.Sprintf("-raw64=%v", testcase.raw64))
-		test_helpers.MountOrExit(test_helpers.DefaultCipherDir, test_helpers.DefaultPlainDir, opts...)
-		r := m.Run()
-		test_helpers.UnmountPanic(test_helpers.DefaultPlainDir)
-		if r != 0 {
-			os.Exit(r)
-		}
-	}
-	os.Exit(0)
-}
-
-// Write "n" zero bytes to filename "fn", read again, compare hash
-func testWriteN(t *testing.T, fn string, n int) string {
-	file, err := os.Create(test_helpers.DefaultPlainDir + "/" + fn)
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	d := make([]byte, n)
-	written, err := file.Write(d)
-	if err != nil || written != len(d) {
-		t.Errorf("err=\"%s\", written=%d", err, written)
-	}
-	err = file.Close()
-	if err != nil {
-		t.Error(err)
-	}
-
-	test_helpers.VerifySize(t, test_helpers.DefaultPlainDir+"/"+fn, n)
-
-	hashWant := test_helpers.Md5hex(d)
-
-	hashActual := test_helpers.Md5fn(test_helpers.DefaultPlainDir + "/" + fn)
-
-	if hashActual != hashWant {
-		t.Errorf("Wrong content, hashWant=%s hashActual=%s", hashWant, hashActual)
-	}
-
-	return hashActual
-}
-
-func TestWrite10(t *testing.T) {
-	testWriteN(t, "10", 10)
-}
-
-func TestWrite100(t *testing.T) {
-	testWriteN(t, "100", 100)
-}
-
-func TestWrite1M(t *testing.T) {
-	testWriteN(t, "1M", 1024*1024)
-}
-
-func TestWrite100x100(t *testing.T) {
-	hashWant := testWriteN(t, "100x100", 100)
-	// Read and check 100 times to catch race conditions
-	var i int
-	for i = 0; i < 100; i++ {
-		hashActual := test_helpers.Md5fn(test_helpers.DefaultPlainDir + "/100")
-		if hashActual != hashWant {
-			fmt.Printf("Read corruption in loop #%d\n", i)
-			t.FailNow()
-		} else {
-			//fmt.Print(".")
-		}
-	}
-}
-
-// Hint for calculating reference md5sums:
-// dd if=/dev/zero count=1 bs=XYZ | md5sum
-func TestTruncate(t *testing.T) {
-	fn := test_helpers.DefaultPlainDir + "/truncate"
-	file, err := os.Create(fn)
-	if err != nil {
-		t.FailNow()
-	}
-	// Grow to two blocks
-	file.Truncate(7000)
-	test_helpers.VerifySize(t, fn, 7000)
-	if md5 := test_helpers.Md5fn(fn); md5 != "95d4ec7038e3e4fdbd5f15c34c3f0b34" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Shrink - needs RMW
-	file.Truncate(6999)
-	test_helpers.VerifySize(t, fn, 6999)
-	if md5 := test_helpers.Md5fn(fn); md5 != "35fd15873ec6c35380064a41b9b9683b" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Shrink to one partial block
-	file.Truncate(465)
-	test_helpers.VerifySize(t, fn, 465)
-	if md5 := test_helpers.Md5fn(fn); md5 != "a1534d6e98a6b21386456a8f66c55260" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Grow to exactly one block
-	file.Truncate(4096)
-	test_helpers.VerifySize(t, fn, 4096)
-	if md5 := test_helpers.Md5fn(fn); md5 != "620f0b67a91f7f74151bc5be745b7110" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Truncate to zero
-	file.Truncate(0)
-	test_helpers.VerifySize(t, fn, 0)
-	// Grow to 10MB (creates file holes)
-	var sz int
-	sz = 10 * 1024 * 1024
-	file.Truncate(int64(sz))
-	test_helpers.VerifySize(t, fn, sz)
-	if md5 := test_helpers.Md5fn(fn); md5 != "f1c9645dbc14efddc7d8a322685f26eb" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Grow to 10MB + 100B (partial block on the end)
-	sz = 10*1024*1024 + 100
-	file.Truncate(int64(sz))
-	test_helpers.VerifySize(t, fn, sz)
-	if md5 := test_helpers.Md5fn(fn); md5 != "c23ea79b857b91a7ff07c6ecf185f1ca" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Grow to 20MB (creates file holes, partial block on the front)
-	sz = 20 * 1024 * 1024
-	file.Truncate(int64(sz))
-	test_helpers.VerifySize(t, fn, sz)
-	if md5 := test_helpers.Md5fn(fn); md5 != "8f4e33f3dc3e414ff94e5fb6905cba8c" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-}
-
-const (
-	// From man statfs
-	TMPFS_MAGIC      = 0x01021994
-	EXT4_SUPER_MAGIC = 0xef53
-)
-
-// isWellKnownFS decides if the backing filesystem is well-known.
-// The expected allocated sizes are only valid on tmpfs and ext4. btrfs
-// gives different results, but that's not an error.
-func isWellKnownFS(fn string) bool {
-	var fs syscall.Statfs_t
-	err := syscall.Statfs(fn, &fs)
-	if err != nil {
-		panic(err)
-	}
-	if fs.Type == EXT4_SUPER_MAGIC || fs.Type == TMPFS_MAGIC {
-		return true
-	}
-	return false
-}
-
-const FALLOC_DEFAULT = 0x00
-const FALLOC_FL_KEEP_SIZE = 0x01
-
-func TestFallocate(t *testing.T) {
-	if runtime.GOOS == "darwin" {
-		t.Skipf("OSX does not support fallocate")
-	}
-	fn := test_helpers.DefaultPlainDir + "/fallocate"
-	file, err := os.Create(fn)
-	if err != nil {
-		t.FailNow()
-	}
-	wellKnown := isWellKnownFS(test_helpers.DefaultCipherDir)
-	fd := int(file.Fd())
-	nBytes := test_helpers.Du(t, fd)
-	if nBytes != 0 {
-		t.Fatalf("Empty file has %d bytes", nBytes)
-	}
-	// Allocate 30 bytes, keep size
-	// gocryptfs ||        (0 blocks)
-	//      ext4 |  d   |  (1 block)
-	err = syscallcompat.Fallocate(fd, FALLOC_FL_KEEP_SIZE, 0, 30)
-	if err != nil {
-		t.Error(err)
-	}
-	var want int64
-	nBytes = test_helpers.Du(t, fd)
-	want = 4096
-	if nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	test_helpers.VerifySize(t, fn, 0)
-	// Three ciphertext blocks. The middle one should be a file hole.
-	// gocryptfs |  h   |   h  | d|   (1 block)
-	//      ext4 |  d  |  h  |  d  |  (2 blocks)
-	// (Note that gocryptfs blocks are slightly bigger than the ext4 blocks,
-	// but the last one is partial)
-	err = file.Truncate(9000)
-	if err != nil {
-		t.Fatal(err)
-	}
-	nBytes = test_helpers.Du(t, fd)
-	want = 2 * 4096
-	if wellKnown && nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	if md5 := test_helpers.Md5fn(fn); md5 != "5420afa22f6423a9f59e669540656bb4" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Allocate the whole file space
-	// gocryptfs |  h   |   h  | d|   (1 block)
-	//      ext4 |  d  |  d  |  d  |  (3 blocks
-	err = syscallcompat.Fallocate(fd, FALLOC_DEFAULT, 0, 9000)
-	if err != nil {
-		t.Fatal(err)
-	}
-	nBytes = test_helpers.Du(t, fd)
-	want = 3 * 4096
-	if nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	// Neither apparent size nor content should have changed
-	test_helpers.VerifySize(t, fn, 9000)
-	if md5 := test_helpers.Md5fn(fn); md5 != "5420afa22f6423a9f59e669540656bb4" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-
-	// Partial block on the end. The first ext4 block is dirtied by the header.
-	// gocryptfs |  h   |   h  | d|   (1 block)
-	//      ext4 |  d  |  h  |  d  |  (2 blocks)
-	file.Truncate(0)
-	file.Truncate(9000)
-	nBytes = test_helpers.Du(t, fd)
-	want = 2 * 4096
-	if wellKnown && nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	// Allocate 10 bytes in the second block
-	// gocryptfs |  h   |   h  | d|   (1 block)
-	//      ext4 |  d  |  d  |  d  |  (3 blocks)
-	syscallcompat.Fallocate(fd, FALLOC_DEFAULT, 5000, 10)
-	nBytes = test_helpers.Du(t, fd)
-	want = 3 * 4096
-	if wellKnown && nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	// Neither apparent size nor content should have changed
-	test_helpers.VerifySize(t, fn, 9000)
-	if md5 := test_helpers.Md5fn(fn); md5 != "5420afa22f6423a9f59e669540656bb4" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Grow the file to 4 blocks
-	// gocryptfs |  h   |  h   |  d   |d|  (2 blocks)
-	//      ext4 |  d  |  d  |  d  |  d  | (4 blocks)
-	syscallcompat.Fallocate(fd, FALLOC_DEFAULT, 15000, 10)
-	nBytes = test_helpers.Du(t, fd)
-	want = 4 * 4096
-	if wellKnown && nBytes != want {
-		t.Errorf("Expected %d allocated bytes, have %d", want, nBytes)
-	}
-	test_helpers.VerifySize(t, fn, 15010)
-	if md5 := test_helpers.Md5fn(fn); md5 != "c4c44c7a41ab7798a79d093eb44f99fc" {
-		t.Errorf("Wrong md5 %s", md5)
-	}
-	// Shrinking a file using fallocate should have no effect
-	for _, off := range []int64{0, 10, 2000, 5000} {
-		for _, sz := range []int64{0, 1, 42, 6000} {
-			syscallcompat.Fallocate(fd, FALLOC_DEFAULT, off, sz)
-			test_helpers.VerifySize(t, fn, 15010)
-			if md5 := test_helpers.Md5fn(fn); md5 != "c4c44c7a41ab7798a79d093eb44f99fc" {
-				t.Errorf("Wrong md5 %s", md5)
-			}
-		}
-	}
-	// Cleanup
-	file.Close()
-	syscall.Unlink(fn)
-	if !wellKnown {
-		// Even though most tests have been executed still, inform the user
-		// that some were disabled
-		t.Skipf("backing fs is not ext4 or tmpfs, skipped some disk-usage checks\n")
-	}
-}
-
-func TestAppend(t *testing.T) {
-	fn := test_helpers.DefaultPlainDir + "/append"
-	file, err := os.Create(fn)
-	if err != nil {
-		t.FailNow()
-	}
-	data := []byte("testdata123456789") // length 17
-	var buf bytes.Buffer
-	var hashWant string
-	for i := 0; i <= 500; i++ {
-		file.Write(data)
-		buf.Write(data)
-		hashWant = test_helpers.Md5hex(buf.Bytes())
-		hashActual := test_helpers.Md5fn(fn)
-		if hashWant != hashActual {
-			t.FailNow()
-		}
-	}
-
-	// Overwrite with the same data
-	// Hash must stay the same
-	file.Seek(0, 0)
-	for i := 0; i <= 500; i++ {
-		file.Write(data)
-		hashActual := test_helpers.Md5fn(fn)
-		if hashWant != hashActual {
-			t.FailNow()
-		}
-	}
-}
-
-// Create a file with holes by writing to offset 0 (block #0) and
-// offset 4096 (block #1).
-func TestFileHoles(t *testing.T) {
-	fn := test_helpers.DefaultPlainDir + "/fileholes"
-	file, err := os.Create(fn)
-	if err != nil {
-		t.Errorf("file create failed")
-	}
-	foo := []byte("foo")
-	file.Write(foo)
-	file.WriteAt(foo, 4096)
-	_, err = ioutil.ReadFile(fn)
-	if err != nil {
-		t.Error(err)
-	}
-}
-
-// sContains - does the slice of strings "haystack" contain "needle"?
-func sContains(haystack []string, needle string) bool {
-	for _, element := range haystack {
-		if element == needle {
-			return true
-		}
-	}
-	return false
-}
-
-func TestRmwRace(t *testing.T) {
-
-	runtime.GOMAXPROCS(10)
-
-	fn := test_helpers.DefaultPlainDir + "/rmwrace"
-	f1, err := os.Create(fn)
-	if err != nil {
-		t.Fatalf("file create failed")
-	}
-	f2, err := os.Create(fn)
-	if err != nil {
-		t.Fatalf("file create failed")
-	}
-
-	oldBlock := bytes.Repeat([]byte("o"), 4096)
-
-	newBlock := bytes.Repeat([]byte("n"), 4096)
-
-	shortBlock := bytes.Repeat([]byte("s"), 16)
-
-	mergedBlock := make([]byte, 4096)
-	copy(mergedBlock, newBlock)
-	copy(mergedBlock[4080:], shortBlock)
-
-	goodMd5 := make(map[string]int)
-
-	for i := 0; i < 1000; i++ {
-		// Reset to [ooooooooo]
-		_, err = f1.WriteAt(oldBlock, 0)
-		if err != nil {
-			t.Fatalf("Write failed")
-		}
-
-		var wg sync.WaitGroup
-		wg.Add(2)
-
-		// Write to the end of the file, [....ssss]
-		go func() {
-			f1.WriteAt(shortBlock, 4080)
-			wg.Done()
-		}()
-
-		// Overwrite to [nnnnnnn]
-		go func() {
-			f2.WriteAt(newBlock, 0)
-			wg.Done()
-		}()
-
-		wg.Wait()
-
-		// The file should be either:
-		// [nnnnnnnnnn] (md5: 6c1660fdabccd448d1359f27b3db3c99) or
-		// [nnnnnnssss] (md5: da885006a6a284530a427c73ce1e5c32)
-		// but it must not be
-		// [oooooossss]
-
-		buf, _ := ioutil.ReadFile(fn)
-		m := test_helpers.Md5hex(buf)
-		goodMd5[m] = goodMd5[m] + 1
-
-		/*
-			if m == "6c1660fdabccd448d1359f27b3db3c99" {
-				fmt.Println(hex.Dump(buf))
-				t.FailNow()
-			}
-		*/
-	}
-}
-
-// With "--plaintextnames", the name "/gocryptfs.conf" is reserved.
-// Otherwise there should be no restrictions.
-func TestFiltered(t *testing.T) {
-	filteredFile := test_helpers.DefaultPlainDir + "/gocryptfs.conf"
-	file, err := os.Create(filteredFile)
-	if testcase.plaintextnames && err == nil {
-		t.Errorf("should have failed but didn't")
-	} else if !testcase.plaintextnames && err != nil {
-		t.Error(err)
-	}
-	file.Close()
-
-	err = os.Remove(filteredFile)
-	if testcase.plaintextnames && err == nil {
-		t.Errorf("should have failed but didn't")
-	} else if !testcase.plaintextnames && err != nil {
-		t.Error(err)
-	}
-}
-
-func TestFilenameEncryption(t *testing.T) {
-	file, err := os.Create(test_helpers.DefaultPlainDir + "/TestFilenameEncryption.txt")
-	file.Close()
-	if err != nil {
-		t.Fatal(err)
-	}
-	_, err = os.Stat(test_helpers.DefaultCipherDir + "/TestFilenameEncryption.txt")
-	if testcase.plaintextnames && err != nil {
-		t.Errorf("plaintextnames not working: %v", err)
-	} else if !testcase.plaintextnames && err == nil {
-		t.Errorf("file name encryption not working")
-	}
-}
-
-// Test Mkdir and Rmdir
-func testMkdirRmdir(t *testing.T) {
-	test_helpers.TestMkdirRmdir(t, test_helpers.DefaultPlainDir)
-}
-
-// Test Rename
-func testRename(t *testing.T) {
-	test_helpers.TestRename(t, test_helpers.DefaultPlainDir)
-}
-
-// Overwrite an empty directory with another directory
-func TestDirOverwrite(t *testing.T) {
-	dir1 := test_helpers.DefaultPlainDir + "/DirOverwrite1"
-	dir2 := test_helpers.DefaultPlainDir + "/DirOverwrite2"
-	err := os.Mkdir(dir1, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = os.Mkdir(dir2, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = syscall.Rename(dir1, dir2)
-	if err != nil {
-		t.Fatal(err)
-	}
-}
-
-func TestLongNames(t *testing.T) {
-	fi, err := ioutil.ReadDir(test_helpers.DefaultCipherDir)
-	if err != nil {
-		t.Fatal(err)
-	}
-	cnt1 := len(fi)
-	wd := test_helpers.DefaultPlainDir + "/"
-	// Create file with long name
-	n255x := string(bytes.Repeat([]byte("x"), 255))
-	f, err := os.Create(wd + n255x)
-	if err != nil {
-		t.Fatalf("Could not create n255x: %v", err)
-	}
-	f.Close()
-	if !test_helpers.VerifyExistence(wd + n255x) {
-		t.Errorf("n255x is not in directory listing")
-	}
-	// Rename long to long
-	n255y := string(bytes.Repeat([]byte("y"), 255))
-	err = os.Rename(wd+n255x, wd+n255y)
-	if err != nil {
-		t.Fatalf("Could not rename n255x to n255y: %v", err)
-	}
-	if !test_helpers.VerifyExistence(wd + n255y) {
-		t.Errorf("n255y is not in directory listing")
-	}
-	// Rename long to short
-	err = os.Rename(wd+n255y, wd+"short")
-	if err != nil {
-		t.Fatalf("Could not rename n255y to short: %v", err)
-	}
-	if !test_helpers.VerifyExistence(wd + "short") {
-		t.Errorf("short is not in directory listing")
-	}
-	// Rename short to long
-	err = os.Rename(wd+"short", wd+n255x)
-	if err != nil {
-		t.Fatalf("Could not rename short to n255x: %v", err)
-	}
-	if !test_helpers.VerifyExistence(wd + n255x) {
-		t.Errorf("255x is not in directory listing II")
-	}
-	// Unlink
-	err = syscall.Unlink(wd + n255x)
-	if err != nil {
-		t.Fatalf("Could not unlink n255x: %v", err)
-	}
-	if test_helpers.VerifyExistence(wd + n255x) {
-		t.Errorf("n255x still there after unlink")
-	}
-	// Long symlink
-	n255s := string(bytes.Repeat([]byte("s"), 255))
-	err = os.Symlink("/", wd+n255s)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if !test_helpers.VerifyExistence(wd + n255s) {
-		t.Errorf("n255s is not in directory listing")
-	}
-	err = syscall.Unlink(wd + n255s)
-	if err != nil {
-		t.Error(err)
-	}
-	// Long dir
-	n255d := string(bytes.Repeat([]byte("d"), 255))
-	err = os.Mkdir(wd+n255d, 0777)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = syscall.Rmdir(wd + n255d)
-	if err != nil {
-		t.Error(err)
-	}
-	// Check for orphaned files
-	fi, err = ioutil.ReadDir(test_helpers.DefaultCipherDir)
-	if err != nil {
-		t.Fatal(err)
-	}
-	cnt2 := len(fi)
-	if cnt1 != cnt2 {
-		t.Errorf("Leftover files, cnt1=%d cnt2=%d", cnt1, cnt2)
-	}
-}
-
-// Create hard link with long name.
-// This was broken up to v1.2.
-func TestLongLink(t *testing.T) {
-	wd := test_helpers.DefaultPlainDir + "/"
-	target := wd + "TestLongLink.target"
-	f, err := os.Create(target)
-	if err != nil {
-		t.Fatalf("%v", err)
-	}
-	f.Close()
-	l255 := string(bytes.Repeat([]byte("l"), 255))
-	err = os.Link(target, wd+l255)
-	if err != nil {
-		t.Error(err)
-	}
-}
-
-func TestLchown(t *testing.T) {
-	name := test_helpers.DefaultPlainDir + "/symlink"
-	err := os.Symlink("/target/does/not/exist", name)
-	if err != nil {
-		t.Fatal(err)
-	}
-	err = os.Chown(name, os.Getuid(), os.Getgid())
-	if err == nil {
-		t.Error("Chown on dangling symlink should fail")
-	}
-	err = os.Lchown(name, os.Getuid(), os.Getgid())
-	if err != nil {
-		t.Error(err)
-	}
-}
-
-// Set nanoseconds by path, symlink
-func TestUtimesNanoSymlink(t *testing.T) {
-	path := test_helpers.DefaultPlainDir + "/utimesnano_symlink"
-	err := os.Symlink("/some/nonexisting/file", path)
-	if err != nil {
-		t.Fatal(err)
-	}
-	// syscall.UtimesNano does not provide a way to pass AT_SYMLINK_NOFOLLOW,
-	// so we call the external utility "touch", which does.
-	cmd := exec.Command("touch", "--no-dereference", path)
-	cmd.Stderr = os.Stderr
-	cmd.Stdout = os.Stdout
-	err = cmd.Run()
-	if err != nil {
-		t.Error(err)
-	}
-}
-
-type utimesTestcaseStruct struct {
-	// Input atime and mtime
-	in [2]syscall.Timespec
-	// Expected output atime and mtime
-	out [2]syscall.Timespec
-}
-
-func compareUtimes(want [2]syscall.Timespec, actual [2]syscall.Timespec) error {
-	tsNames := []string{"atime", "mtime"}
-	for i := range want {
-		if want[i].Sec != actual[i].Sec {
-			return fmt.Errorf("Wrong %s seconds: want=%d actual=%d", tsNames[i], want[i].Sec, actual[i].Sec)
-		}
-		if want[i].Nsec != actual[i].Nsec {
-			return fmt.Errorf("Wrong %s nanoseconds: want=%d actual=%d", tsNames[i], want[i].Nsec, actual[i].Nsec)
-		}
-	}
-	return nil
-}
-
-const _UTIME_OMIT = ((1 << 30) - 2)
-
-// doTestUtimesNano verifies that setting nanosecond-precision times on "path"
-// works correctly. Pass "/proc/self/fd/N" to test a file descriptor.
-func doTestUtimesNano(t *testing.T, path string) {
-	utimeTestcases := []utimesTestcaseStruct{
-		{
-			in:  [2]syscall.Timespec{{Sec: 50, Nsec: 0}, {Sec: 50, Nsec: 0}},
-			out: [2]syscall.Timespec{{Sec: 50, Nsec: 0}, {Sec: 50, Nsec: 0}},
-		},
-		{
-			in:  [2]syscall.Timespec{{Sec: 1, Nsec: 2}, {Sec: 3, Nsec: 4}},
-			out: [2]syscall.Timespec{{Sec: 1, Nsec: 2}, {Sec: 3, Nsec: 4}},
-		},
-		{
-			in:  [2]syscall.Timespec{{Sec: 7, Nsec: 8}, {Sec: 99, Nsec: _UTIME_OMIT}},
-			out: [2]syscall.Timespec{{Sec: 7, Nsec: 8}, {Sec: 3, Nsec: 4}},
-		},
-		{
-			in:  [2]syscall.Timespec{{Sec: 99, Nsec: _UTIME_OMIT}, {Sec: 5, Nsec: 6}},
-			out: [2]syscall.Timespec{{Sec: 7, Nsec: 8}, {Sec: 5, Nsec: 6}},
-		},
-	}
-	for i, tc := range utimeTestcases {
-		err := syscall.UtimesNano(path, tc.in[:])
-		if err != nil {
-			t.Fatal(err)
-		}
-		var st syscall.Stat_t
-		err = syscall.Stat(path, &st)
-		if err != nil {
-			t.Fatal(err)
-		}
-		err = compareUtimes(tc.out, extractAtimeMtime(st))
-		if err != nil {
-			t.Errorf("Testcase %d: %v", i, err)
-		}
-	}
-}
-
-// Set nanoseconds by path, normal file
-func TestUtimesNano(t *testing.T) {
-	path := test_helpers.DefaultPlainDir + "/utimesnano"
-	err := ioutil.WriteFile(path, []byte("foobar"), 0600)
-	if err != nil {
-		t.Fatal(err)
-	}
-	doTestUtimesNano(t, path)
-}
-
-// Set nanoseconds by fd
-func TestUtimesNanoFd(t *testing.T) {
-	path := test_helpers.DefaultPlainDir + "/utimesnanofd"
-	f, err := os.Create(path)
-	if err != nil {
-		t.Fatal(err)
-	}
-	procPath := fmt.Sprintf("/proc/self/fd/%d", f.Fd())
-	doTestUtimesNano(t, procPath)
-}
diff --git a/tests/plaintextnames/plaintextnames_test.go b/tests/plaintextnames/plaintextnames_test.go
deleted file mode 100644
index cda5149..0000000
--- a/tests/plaintextnames/plaintextnames_test.go
+++ /dev/null
@@ -1,84 +0,0 @@
-package plaintextnames
-
-// integration tests that target plaintextnames specifically
-
-import (
-	"io/ioutil"
-	"os"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/internal/configfile"
-
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-var cDir string
-var pDir string
-
-// Create and mount "-plaintextnames" fs
-func TestMain(m *testing.M) {
-	cDir = test_helpers.InitFS(nil, "-plaintextnames")
-	pDir = cDir + ".mnt"
-	test_helpers.MountOrExit(cDir, pDir, "-extpass", "echo test")
-	r := m.Run()
-	test_helpers.UnmountPanic(pDir)
-	os.Exit(r)
-}
-
-// Only the PlaintextNames feature flag should be set
-func TestFlags(t *testing.T) {
-	_, cf, err := configfile.LoadConfFile(cDir+"/gocryptfs.conf", "test")
-	if err != nil {
-		t.Fatal(err)
-	}
-	if !cf.IsFeatureFlagSet(configfile.FlagPlaintextNames) {
-		t.Error("PlaintextNames flag should be set but isn't")
-	}
-	if cf.IsFeatureFlagSet(configfile.FlagEMENames) || cf.IsFeatureFlagSet(configfile.FlagDirIV) {
-		t.Error("FlagEMENames and FlagDirIV should be not set")
-	}
-}
-
-// gocryptfs.diriv should NOT be created
-func TestDirIV(t *testing.T) {
-	_, err := os.Stat(cDir + "/gocryptfs.diriv")
-	if err == nil {
-		t.Errorf("gocryptfs.diriv should not be created in the top directory")
-	}
-	err = os.Mkdir(pDir+"/dir1", 0777)
-	if err != nil {
-		t.Error(err)
-	}
-	_, err = os.Stat(pDir + "/dir1/gocryptfs.diriv")
-	if err == nil {
-		t.Errorf("gocryptfs.diriv should not be created in a subdirectory")
-	}
-}
-
-// With "-plaintextnames", the name "/gocryptfs.conf" is reserved, but everything
-// else should work.
-func TestFiltered(t *testing.T) {
-	filteredFile := pDir + "/gocryptfs.conf"
-	err := ioutil.WriteFile(filteredFile, []byte("foo"), 0777)
-	if err == nil {
-		t.Errorf("should have failed but didn't")
-	}
-	err = os.Remove(filteredFile)
-	if err == nil {
-		t.Errorf("should have failed but didn't")
-	}
-	err = ioutil.WriteFile(pDir+"/gocryptfs.diriv", []byte("foo"), 0777)
-	if err != nil {
-		t.Error(err)
-	}
-	subDir, err := ioutil.TempDir(pDir, "")
-	if err != nil {
-		t.Fatal(err)
-	}
-	fd, err := os.Create(subDir + "/gocryptfs.conf")
-	if err != nil {
-		t.Error(err)
-	} else {
-		fd.Close()
-	}
-}
diff --git a/tests/reverse/correctness_test.go b/tests/reverse/correctness_test.go
deleted file mode 100644
index db64983..0000000
--- a/tests/reverse/correctness_test.go
+++ /dev/null
@@ -1,91 +0,0 @@
-package reverse_test
-
-import (
-	"io/ioutil"
-	"os"
-	"syscall"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-func TestLongnameStat(t *testing.T) {
-	fd, err := os.Create(dirA + "/" + x240)
-	if err != nil {
-		t.Fatal(err)
-	}
-	path := dirC + "/" + x240
-	if !test_helpers.VerifyExistence(path) {
-		t.Fail()
-	}
-	test_helpers.VerifySize(t, path, 0)
-	_, err = fd.Write(make([]byte, 10))
-	if err != nil {
-		t.Fatal(err)
-	}
-	fd.Close()
-	/*
-		time.Sleep(1000 * time.Millisecond)
-		test_helpers.VerifySize(t, path, 10)
-	*/
-}
-
-func TestSymlinks(t *testing.T) {
-	target := "/"
-	os.Symlink(target, dirA+"/symlink")
-	cSymlink := dirC + "/symlink"
-	_, err := os.Lstat(cSymlink)
-	if err != nil {
-		t.Errorf("Lstat: %v", err)
-	}
-	_, err = os.Stat(cSymlink)
-	if err != nil {
-		t.Errorf("Stat: %v", err)
-	}
-	actualTarget, err := os.Readlink(cSymlink)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if target != actualTarget {
-		t.Errorf("wrong symlink target: want=%q have=%q", target, actualTarget)
-	}
-}
-
-// .gocryptfs.reverse.conf in the plaintext dir should be visible as
-// gocryptfs.conf
-func TestConfigMapping(t *testing.T) {
-	c := dirB + "/gocryptfs.conf"
-	if !test_helpers.VerifyExistence(c) {
-		t.Errorf("%s missing", c)
-	}
-	data, err := ioutil.ReadFile(c)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if len(data) == 0 {
-		t.Errorf("empty file")
-	}
-}
-
-// Check that the access() syscall works on virtual files
-func TestAccessVirtual(t *testing.T) {
-	if plaintextnames {
-		t.Skip()
-	}
-	var R_OK uint32 = 4
-	var W_OK uint32 = 2
-	var X_OK uint32 = 1
-	fn := dirB + "/gocryptfs.diriv"
-	err := syscall.Access(fn, R_OK)
-	if err != nil {
-		t.Errorf("%q should be readable, but got error: %v", fn, err)
-	}
-	err = syscall.Access(fn, W_OK)
-	if err == nil {
-		t.Errorf("should NOT be writeable")
-	}
-	err = syscall.Access(fn, X_OK)
-	if err == nil {
-		t.Errorf("should NOT be executable")
-	}
-}
diff --git a/tests/reverse/ctlsock_test.go b/tests/reverse/ctlsock_test.go
deleted file mode 100644
index 8a7d462..0000000
--- a/tests/reverse/ctlsock_test.go
+++ /dev/null
@@ -1,68 +0,0 @@
-package reverse_test
-
-import (
-	"io/ioutil"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/internal/ctlsock"
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-var ctlSockTestCases = [][]string{
-	{"4RQq1dJlfvQPaVU5Xypf0w==", "file"},
-	{"gocryptfs.longname.ZQCAoi5li3xvDZRO8McBV0L_kzJc4IcAOEzuW-2S1Y4=", "longfile." + x240},
-	{"v6puXntoQOk7Mhl8zJ4Idg==", "dir"},
-	{"v6puXntoQOk7Mhl8zJ4Idg==/UVy2gV0RQTUC8AE4wYoMwg==", "dir/file"},
-	{"v6puXntoQOk7Mhl8zJ4Idg==/fvHFLHlxHCQ7EpVMJu0AZg==", "dir/dir"},
-	{"v6puXntoQOk7Mhl8zJ4Idg==/fvHFLHlxHCQ7EpVMJu0AZg==/_4uudIGniACke55JoDsqDA==", "dir/dir/dir"},
-	{"v6puXntoQOk7Mhl8zJ4Idg==/fvHFLHlxHCQ7EpVMJu0AZg==/QvPahkkeVRKTw2kdZFZxwQ==", "dir/dir/file"},
-	{"v6puXntoQOk7Mhl8zJ4Idg==/gocryptfs.longname.y6rxCn6Id8hIZL2t_STpdLZpu-aE2HpprJR25xD60mk=", "dir/longfile." + x240},
-	{"gocryptfs.longname.cvRximo1ATRJVEzw_V9MZieHFlod9y2iv2Sug1kbiTE=", "longdir." + x240},
-	{"gocryptfs.longname.cvRximo1ATRJVEzw_V9MZieHFlod9y2iv2Sug1kbiTE=/-LMdFgFt6UxO-z5iJvuC9w==", "longdir." + x240 + "/dir"},
-	{"gocryptfs.longname.cvRximo1ATRJVEzw_V9MZieHFlod9y2iv2Sug1kbiTE=/rBPJYAzcHWLdPj1T8kgh8A==", "longdir." + x240 + "/file"},
-}
-
-// Test DecryptPath and EncryptPath
-func TestCtlSockPathOps(t *testing.T) {
-	mnt, err := ioutil.TempDir(test_helpers.TmpDir, "reverse_mnt_")
-	if err != nil {
-		t.Fatal(err)
-	}
-	sock := mnt + ".sock"
-	test_helpers.MountOrFatal(t, "ctlsock_reverse_test_fs", mnt, "-reverse", "-extpass", "echo test", "-ctlsock="+sock)
-	defer test_helpers.UnmountPanic(mnt)
-	var req ctlsock.RequestStruct
-	for i, tc := range ctlSockTestCases {
-		// Decrypt
-		req = ctlsock.RequestStruct{DecryptPath: tc[0]}
-		response := test_helpers.QueryCtlSock(t, sock, req)
-		if response.ErrNo != 0 {
-			t.Errorf("Testcase %d Decrypt: %q ErrNo=%d ErrText=%s", i, tc[0], response.ErrNo, response.ErrText)
-		} else if response.Result != tc[1] {
-			t.Errorf("Testcase %d Decrypt: Want %q got %q", i, tc[1], response.Result)
-		}
-		// Encrypt
-		req = ctlsock.RequestStruct{EncryptPath: tc[1]}
-		response = test_helpers.QueryCtlSock(t, sock, req)
-		if response.ErrNo != 0 {
-			t.Errorf("Testcase %d Encrypt: %q ErrNo=%d ErrText=%s", i, tc[0], response.ErrNo, response.ErrText)
-		} else if response.Result != tc[0] {
-			t.Errorf("Testcase %d Encrypt: Want %q got %q", i, tc[1], response.Result)
-		}
-	}
-}
-
-// We should not panic when somebody feeds requests that make no sense
-func TestCtlSockCrash(t *testing.T) {
-	mnt, err := ioutil.TempDir(test_helpers.TmpDir, "reverse_mnt_")
-	if err != nil {
-		t.Fatal(err)
-	}
-	sock := mnt + ".sock"
-	test_helpers.MountOrFatal(t, "ctlsock_reverse_test_fs", mnt, "-reverse", "-extpass", "echo test", "-ctlsock="+sock,
-		"-wpanic=0", "-nosyslog=0")
-	defer test_helpers.UnmountPanic(mnt)
-	// Try to crash it
-	req := ctlsock.RequestStruct{DecryptPath: "gocryptfs.longname.XXX_TestCtlSockCrash_XXX.name"}
-	test_helpers.QueryCtlSock(t, sock, req)
-}
diff --git a/tests/reverse/longname_perf_test.go b/tests/reverse/longname_perf_test.go
deleted file mode 100644
index 1707cea..0000000
--- a/tests/reverse/longname_perf_test.go
+++ /dev/null
@@ -1,50 +0,0 @@
-package reverse_test
-
-import (
-	"fmt"
-	"os"
-	"testing"
-)
-
-func genName(i int, postfix string) string {
-	return fmt.Sprintf("%04d.%s", i, postfix)
-}
-
-// Create 10000 files with long names
-func generateLongnameFiles(dir string) {
-	for i := 0; i < 100000; i++ {
-		n := genName(i, x240)
-		f, err := os.Create(dir + "/" + n)
-		if err != nil {
-			panic(err)
-		}
-		f.Close()
-	}
-}
-
-func BenchmarkLongnameStat(b *testing.B) {
-	// Setup
-	generateLongnameFiles(dirA)
-	dirFd, err := os.Open(dirB)
-	if err != nil {
-		b.Fatal(err)
-	}
-	encryptedNames, err := dirFd.Readdirnames(-1)
-	if err != nil {
-		b.Fatal(err)
-	}
-	l := len(encryptedNames)
-	dirFd.Close()
-	// Benchmark
-	b.ResetTimer()
-	for i := 0; i < b.N; i++ {
-		_, err := os.Stat(dirB + "/" + encryptedNames[i%l])
-		if err != nil {
-			b.Fatal(err)
-		}
-	}
-	// Cleanup
-	b.StopTimer()
-	os.RemoveAll(dirA)
-	os.Mkdir(dirA, 0700)
-}
diff --git a/tests/reverse/main_test.go b/tests/reverse/main_test.go
deleted file mode 100644
index 3425289..0000000
--- a/tests/reverse/main_test.go
+++ /dev/null
@@ -1,56 +0,0 @@
-package reverse_test
-
-import (
-	"bytes"
-	"os"
-	"testing"
-
-	"github.com/rfjakob/gocryptfs/tests/test_helpers"
-)
-
-var x240 = string(bytes.Repeat([]byte("x"), 240))
-var plaintextnames bool
-
-// dirA is a normal directory
-var dirA string
-
-// dirB is the reverse mount backed by dirA
-var dirB string
-
-// dirC is a forward mount backed by dirB
-var dirC string
-
-// Create directory "dirA", mount it reverse to "dirB", mount it forward
-// to "dirC".
-func TestMain(m *testing.M) {
-	var r int
-	for _, plaintextnames = range []bool{false, true} {
-		argsA := []string{"-reverse"}
-		if plaintextnames {
-			argsA = append(argsA, "-plaintextnames")
-		}
-		dirA = test_helpers.InitFS(nil, argsA...)
-		dirB = test_helpers.TmpDir + "/b"
-		dirC = test_helpers.TmpDir + "/c"
-		if err := os.Mkdir(dirB, 0700); err != nil {
-			panic(err)
-		}
-		if err := os.Mkdir(dirC, 0700); err != nil {
-			panic(err)
-		}
-		test_helpers.MountOrExit(dirA, dirB, "-reverse", "-extpass", "echo test")
-		test_helpers.MountOrExit(dirB, dirC, "-extpass", "echo test")
-		r = m.Run()
-		test_helpers.UnmountPanic(dirC)
-		test_helpers.UnmountPanic(dirB)
-
-		os.RemoveAll(dirA)
-		os.RemoveAll(dirB)
-		os.RemoveAll(dirC)
-
-		if r != 0 {
-			os.Exit(r)
-		}
-	}
-	os.Exit(r)
-}
